"""
Core Data Models for QML Trading System
========================================
Standardized dataclasses for all system components.
These replace loose dictionaries with type-safe, validated structures.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional
import numpy as np


# =============================================================================
# ENUMS
# =============================================================================

class SignalType(str, Enum):
    """Type of trading signal."""
    BUY = "BUY"
    SELL = "SELL"


class Side(str, Enum):
    """Trade side/direction."""
    LONG = "LONG"
    SHORT = "SHORT"


class TradeResult(str, Enum):
    """Outcome of a trade."""
    WIN = "WIN"
    LOSS = "LOSS"
    BREAKEVEN = "BREAKEVEN"
    PENDING = "PENDING"


class PatternDirection(str, Enum):
    """Direction of detected pattern."""
    BULLISH = "bullish"
    BEARISH = "bearish"


class SwingType(str, Enum):
    """Type of swing point."""
    HIGH = "HIGH"
    LOW = "LOW"


# =============================================================================
# CANDLE
# =============================================================================

@dataclass
class Candle:
    """
    Single OHLCV candlestick.
    
    This is the atomic unit of price data in the system.
    All timestamps are expected to be UTC.
    """
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    
    # Optional fields
    index: Optional[int] = None  # Bar index in series
    symbol: Optional[str] = None
    timeframe: Optional[str] = None
    
    @property
    def body(self) -> float:
        """Absolute candle body size."""
        return abs(self.close - self.open)
    
    @property
    def range(self) -> float:
        """Total candle range (high - low)."""
        return self.high - self.low
    
    @property
    def is_bullish(self) -> bool:
        """True if close > open."""
        return self.close > self.open
    
    @property
    def upper_wick(self) -> float:
        """Upper wick size."""
        return self.high - max(self.open, self.close)
    
    @property
    def lower_wick(self) -> float:
        """Lower wick size."""
        return min(self.open, self.close) - self.low
    
    def __post_init__(self):
        """Validate candle data."""
        if self.high < self.low:
            raise ValueError(f"Invalid candle: high ({self.high}) < low ({self.low})")
        if self.high < max(self.open, self.close):
            raise ValueError(f"Invalid candle: high must be >= open and close")
        if self.low > min(self.open, self.close):
            raise ValueError(f"Invalid candle: low must be <= open and close")


# =============================================================================
# SIGNAL
# =============================================================================

@dataclass
class Signal:
    """
    Trading signal generated by a detector.
    
    Represents a BUY or SELL opportunity identified by the detection system.
    Contains all information needed for trade execution.
    """
    timestamp: datetime
    signal_type: SignalType  # BUY or SELL
    price: float  # Suggested entry price
    strategy_name: str  # Name of the strategy that generated this signal
    
    # Signal quality
    confidence: float = 0.0  # 0.0 to 1.0
    validity_score: float = 0.0  # Pattern validity score
    
    # Trading levels (optional but recommended)
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    take_profit_2: Optional[float] = None
    take_profit_3: Optional[float] = None
    
    # Pattern information
    pattern_type: Optional[str] = None  # e.g., "QML_BULLISH", "QML_BEARISH"
    pattern_id: Optional[str] = None  # Unique pattern identifier
    
    # Additional context
    symbol: Optional[str] = None
    timeframe: Optional[str] = None
    atr_at_signal: Optional[float] = None
    
    # Flexible metadata for strategy-specific data
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def risk_amount(self) -> Optional[float]:
        """Calculate risk amount if stop loss is set."""
        if self.stop_loss is None:
            return None
        return abs(self.price - self.stop_loss)
    
    @property
    def risk_reward(self) -> Optional[float]:
        """Calculate risk/reward ratio if TP and SL are set."""
        if self.stop_loss is None or self.take_profit is None:
            return None
        risk = abs(self.price - self.stop_loss)
        reward = abs(self.take_profit - self.price)
        return reward / risk if risk > 0 else None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'timestamp': self.timestamp.isoformat() if self.timestamp else None,
            'signal_type': self.signal_type.value,
            'price': self.price,
            'strategy_name': self.strategy_name,
            'confidence': self.confidence,
            'validity_score': self.validity_score,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'take_profit_2': self.take_profit_2,
            'take_profit_3': self.take_profit_3,
            'pattern_type': self.pattern_type,
            'pattern_id': self.pattern_id,
            'symbol': self.symbol,
            'timeframe': self.timeframe,
            'atr_at_signal': self.atr_at_signal,
            'metadata': self.metadata,
        }


# =============================================================================
# TRADE
# =============================================================================

@dataclass
class Trade:
    """
    Completed or pending trade record.
    
    Represents a full trade lifecycle from entry to exit.
    Used for backtesting, paper trading, and live trading records.
    """
    # Entry information
    entry_time: datetime
    entry_price: float
    side: Side  # LONG or SHORT
    
    # Exit information (None if trade is still open)
    exit_time: Optional[datetime] = None
    exit_price: Optional[float] = None
    
    # Position sizing
    quantity: float = 1.0  # Position size in units
    position_value: Optional[float] = None  # Position value in quote currency
    
    # Trade management levels
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    
    # Results (filled after exit)
    pnl_pct: Optional[float] = None  # Percentage P&L
    pnl_usd: Optional[float] = None  # Absolute P&L in USD
    result: TradeResult = TradeResult.PENDING
    
    # Trade context
    symbol: Optional[str] = None
    timeframe: Optional[str] = None
    strategy_name: Optional[str] = None
    
    # Signal that triggered this trade
    signal_id: Optional[str] = None
    pattern_type: Optional[str] = None
    
    # Execution details
    commission: float = 0.0
    slippage: float = 0.0
    
    # Duration metrics
    bars_held: Optional[int] = None
    
    # Flexible metadata
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def is_open(self) -> bool:
        """Check if trade is still open."""
        return self.exit_time is None
    
    @property
    def is_winner(self) -> bool:
        """Check if trade is a winner."""
        return self.result == TradeResult.WIN
    
    @property
    def is_loser(self) -> bool:
        """Check if trade is a loser."""
        return self.result == TradeResult.LOSS
    
    def close(self, exit_time: datetime, exit_price: float) -> None:
        """
        Close the trade and calculate P&L.
        
        Args:
            exit_time: Time of exit
            exit_price: Exit price
        """
        self.exit_time = exit_time
        self.exit_price = exit_price
        
        # Calculate P&L
        if self.side == Side.LONG:
            self.pnl_pct = ((exit_price - self.entry_price) / self.entry_price) * 100
        else:  # SHORT
            self.pnl_pct = ((self.entry_price - exit_price) / self.entry_price) * 100
        
        # Subtract commission
        self.pnl_pct -= (self.commission * 2)  # Entry and exit commission
        
        if self.position_value:
            self.pnl_usd = self.position_value * (self.pnl_pct / 100)
        
        # Determine result
        if self.pnl_pct > 0.01:  # Small threshold for breakeven
            self.result = TradeResult.WIN
        elif self.pnl_pct < -0.01:
            self.result = TradeResult.LOSS
        else:
            self.result = TradeResult.BREAKEVEN
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'entry_time': self.entry_time.isoformat() if self.entry_time else None,
            'exit_time': self.exit_time.isoformat() if self.exit_time else None,
            'entry_price': self.entry_price,
            'exit_price': self.exit_price,
            'side': self.side.value,
            'quantity': self.quantity,
            'position_value': self.position_value,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'pnl_pct': self.pnl_pct,
            'pnl_usd': self.pnl_usd,
            'result': self.result.value,
            'symbol': self.symbol,
            'timeframe': self.timeframe,
            'strategy_name': self.strategy_name,
            'signal_id': self.signal_id,
            'pattern_type': self.pattern_type,
            'commission': self.commission,
            'slippage': self.slippage,
            'bars_held': self.bars_held,
            'metadata': self.metadata,
        }


# =============================================================================
# SWING POINT
# =============================================================================

@dataclass
class SwingPoint:
    """
    Confirmed swing high or swing low point.
    
    Represents a local price extreme that has been confirmed
    by subsequent price action (e.g., ATR reversal).
    """
    swing_type: SwingType  # HIGH or LOW
    price: float
    timestamp: datetime
    bar_index: int
    
    # Confirmation details
    confirmed: bool = False
    confirmation_timestamp: Optional[datetime] = None
    confirmation_bar_index: Optional[int] = None
    confirmation_price: Optional[float] = None
    
    # Volatility context
    atr_at_point: Optional[float] = None
    significance: float = 0.0  # ATR-normalized significance
    
    # Metadata
    symbol: Optional[str] = None
    timeframe: Optional[str] = None
    
    @property
    def is_high(self) -> bool:
        """Check if this is a swing high."""
        return self.swing_type == SwingType.HIGH
    
    @property
    def is_low(self) -> bool:
        """Check if this is a swing low."""
        return self.swing_type == SwingType.LOW


# =============================================================================
# LIST OF CANDLES HELPER
# =============================================================================

@dataclass
class CandleList:
    """
    Wrapper for a list of candles with helper methods.
    
    Provides convenient access to OHLCV arrays and calculated values.
    """
    candles: List[Candle] = field(default_factory=list)
    
    def __len__(self) -> int:
        return len(self.candles)
    
    def __getitem__(self, idx) -> Candle:
        return self.candles[idx]
    
    def __iter__(self):
        return iter(self.candles)
    
    @property
    def opens(self) -> np.ndarray:
        """Get open prices as numpy array."""
        return np.array([c.open for c in self.candles])
    
    @property
    def highs(self) -> np.ndarray:
        """Get high prices as numpy array."""
        return np.array([c.high for c in self.candles])
    
    @property
    def lows(self) -> np.ndarray:
        """Get low prices as numpy array."""
        return np.array([c.low for c in self.candles])
    
    @property
    def closes(self) -> np.ndarray:
        """Get close prices as numpy array."""
        return np.array([c.close for c in self.candles])
    
    @property
    def volumes(self) -> np.ndarray:
        """Get volumes as numpy array."""
        return np.array([c.volume for c in self.candles])
    
    @property
    def timestamps(self) -> List[datetime]:
        """Get timestamps."""
        return [c.timestamp for c in self.candles]
    
    def last(self, n: int = 1) -> List[Candle]:
        """Get last n candles."""
        return self.candles[-n:]
    
    def first(self, n: int = 1) -> List[Candle]:
        """Get first n candles."""
        return self.candles[:n]
